package ising

import (
	"bytes"
	"encoding/binary"

	. "github.com/nknorg/nkn/common"
	"github.com/nknorg/nkn/core/ledger"
)

// HeightHashToString uses block height and block hash to generate a uniq string
func HeightHashToString(height uint32, blockHash Uint256) string {
	buff := bytes.NewBuffer(nil)
	binary.Write(buff, binary.LittleEndian, height)
	buff.Write(blockHash.ToArray())

	return buff.String()
}

// StringToHeightHash recovers block height and block hash from string which generated by HeightHashToString
func StringToHeightHash(str string) (uint32, Uint256) {
	var height uint32
	var hash Uint256
	buff := bytes.NewReader([]byte(str))
	binary.Read(buff, binary.LittleEndian, &height)
	hash.Deserialize(buff)

	return height, hash
}

// HasAbilityToVerifyBlock checks if local node can verify the block.
func HasAbilityToVerifyBlock(block *ledger.Block) bool {
	// get current block
	currentBlockHeight := ledger.DefaultLedger.Store.GetHeight()
	currentBlock, err := ledger.DefaultLedger.Store.GetBlockByHeight(currentBlockHeight)
	if err != nil {
		return false
	}
	// check if can link to previous block
	if block.Header.PrevBlockHash.CompareTo(currentBlock.Header.Hash()) != 0 {
		return false
	}
	// check block height
	if block.Header.Height != currentBlockHeight+1 {
		return false
	}

	return true
}
